# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

jasper.error.emptybodycontent.nonempty=根据 TLD，[{0}] 标签必须为空，但不是

jsp.error.action.isnottagfile=[{0}]行为只能用于标签文件
jsp.error.attempt_to_clear_flushed_buffer=错误：尝试清空已刷新的缓冲区
jsp.error.attribute.deferredmix=不能在同一属性值中同时使用 ${} 和 #{} EL 表达式
jsp.error.attribute.noequal=期望的符号是等号
jsp.error.attribute.noescape=属性值[{0}]引用[{1}]，在值内使用时必须被转义。
jsp.error.attribute.nowhitespace=JSP 规范要求一个属性名字前有空格
jsp.error.backgroundCompilationFailed=后台编译失败
jsp.error.bad.scratch.dir=你指定的 scratchDir：[{0}] 不可用。
jsp.error.bad_attribute=属性[{0}]无效为tag[{1}] 通过TLD
jsp.error.beans.noproperty=在[{1}]类型bean中找不到任何有关属性[{0}]的信息
jsp.error.beans.nullbean=尝试获取一个bean 操作在一个空对象上.
jsp.error.cannotAddResolver=在第一次请求发生之后不能调用addELResolver
jsp.error.compilation.source=加载源文件时出错[{0}]
jsp.error.compiler=没有可用的Java编译器
jsp.error.corresponding.servlet=生成的servlet错误:\n
jsp.error.could.not.add.taglibraries=不能增加一个或者多个tag 库.
jsp.error.data.file.processing=处理文件 [{0}] 错误
jsp.error.el.template.deferred=#{...} 不允许出现在模板文本中
jsp.error.fallback.invalidUse=jsp:fallback必须是jsp:plugin的直接子代
jsp.error.file.cannot.read=无法读取文件 [{0}]
jsp.error.file.not.found=文.件[{0}] 未找到
jsp.error.include.exception=无法包含[{0}]
jsp.error.include.tag=无效的jsp:include标签
jsp.error.internal.filenotfound=内部错误：找不到文件 [{0}]
jsp.error.internal.unexpectedNodeType=节点类型不一致
jsp.error.invalid.tagdir=标签文件目录 [{0}] 不以"/WEB-INF/tags"开头
jsp.error.invalid.version=为标签 [{0}] 定义了无效的 JSP 版本号
jsp.error.ise_on_clear=当缓存大小等于0时调用clear()函数是非法的
jsp.error.jspbody.emptybody.only=标签[{}]的标签体内智能包含jsp:attribute
jsp.error.jspbody.required=如果使用 jsp:attribute，则必须使用 jsp:body 为 [{0}] 指定标记正文。
jsp.error.jspelement.missing.name=XML强制性约束：属性name缺失。
jsp.error.jspoutput.doctypenamesystem=&lt;jsp:output&gt;: 'doctype-root-element' 和 'doctype-system' 必须一起出现
jsp.error.jsproot.version.invalid=版本号 [{0}] 无效，版本号必须是"1.2"、"2.0"、"2.1"、"2.2"、"2.3"中的一个
jsp.error.lastModified=无法确定文件 [{0}] 的最后修改日期
jsp.error.loadclass.taghandler=无法为TAG [{1}]加载标记处理程序类[{0}]
jsp.error.location=行.: [{0}], 列: [{1}]
jsp.error.mandatory.attribute=[{0}]: 强制性属性 [{1}] 缺失。
jsp.error.negativeBufferSize=缓存大小是负数
jsp.error.nested.jspbody=JSP：体标准动作不能嵌套在另一个jsp:body 或者 jsp:属性标准动作中
jsp.error.nested_jsproot=嵌套的&lt;jsp:root&gt;
jsp.error.no.scratch.dir=JSP引擎未配置scratch文件夹。\n\
请在对应上下文Context的servlets.properties文件中添加"jsp.initparams=scratchdir=<dir-name>"。
jsp.error.no.scriptlets=脚本( &lt;%!, &lt;jsp声明, &lt;%=, &lt;jsp表达式, &lt;%, &lt;jsp脚本变量 )不允许出现在这里
jsp.error.noFunction=无法使用指定的前缀找到函数[{0}]
jsp.error.not.in.template=在模板文本体中, [{0}] 是不允许的.
jsp.error.outputfolder=无输出目录
jsp.error.overflow=错误：JSP缓冲区溢出
jsp.error.page.conflict.errorpage=页指令：不同值的多次出现“errorPage”的非法值（旧:[{0}],新:[{1}]）
jsp.error.page.invalid.deferredsyntaxallowedasliteral=页面指令：deferredSyntaxAllowedAsLiteral的值无效
jsp.error.page.invalid.iselignored=页面指令：忽略的无效值
jsp.error.page.invalid.session=页面提示：session值无效
jsp.error.page.multi.pageencoding=页指令不能有多次出现的页编码
jsp.error.page.nullThrowable=空异常
jsp.error.param.invalidUse=jsp:param 不能在jsp:include、jsp:forward或jsp:params等元素外使用
jsp.error.paramexpected=使用“name”和“value”属性期望“jsp:param”标准操作
jsp.error.parse.xml=无法解析 XML 文件 [{0}]
jsp.error.parse.xml.invalidPublicId=无效的 PUBLIC ID: [{0}]
jsp.error.plugin.wrongRootElement=[{0}] 中的根元素的名称与 [{1}] 的不同
jsp.error.precompilation=无法预编译JSP[{0}]
jsp.error.precompilation.parameter=不能将预编译请求参数[{0}]设置为[{1}]
jsp.error.prolog_pagedir_encoding_mismatch=指定在XML语言[{0}]的网页编码是不同于指定在网页的指令[{1}]。
jsp.error.quotes.unterminated=未终结的引号
jsp.error.reload=servlet重新加载失败
jsp.error.scripting.variable.missing_name=无法从属性[{0}]确定脚本变量名称
jsp.error.securityPreload=预加载类时出错
jsp.error.servlet.invalid.method=JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS
jsp.error.simpletag.badbodycontent=对于一下简单的标记符，用于类[{0}]的标记描述符指定了一个无效的body内容（JSP）中
jsp.error.single.line.number=JSP文件：[{1}] 的第 [{0}] 行发生了一个错误
jsp.error.stream.close.failed=流.关闭失败
jsp.error.stream.closed=流.关闭
jsp.error.tag.invalid.trimdirectivewhitespaces=TAG指令：trimDirectiveWhitespaces的值无效
jsp.error.tagfile.nameFrom.badAttribute=\n\
\ 属性指令（在行[{1}]中声明并且其name属性为[{0}]，此name-from-attribute属性的值）必须是java.lang.String类型，是“required”而不是一个“rtexprvalue”。
jsp.error.taglibDirective.absUriCannotBeResolved=无法在web.xml或使用此应用程序部署的jar文件中解析绝对uri：[{0}]
jsp.error.taglibDirective.missing.location='uri'和'tagdir' 属性均未指定。
jsp.error.taglibDirective.uriInvalid=为标签库[{0}]提供的URI不是有效的URI
jsp.error.teiclass.instantiation=无法加载或实例化TagExtraInfo类：[{0}]。
jsp.error.tld.mandatory.element.missing=TLD [{1}] 中强制 TLD 元素 [{0}] 不存在或为空
jsp.error.unable.deleteClassFile=无法删除class文件
jsp.error.unable.load=无法加载JSP的相关类
jsp.error.unable.renameClassFile=无法重命名类文件
jsp.error.unable.to_find_method=不能为属性:[{0}]找到setter 方法.
jsp.error.unavailable=JSP已被标记为不可用
jsp.error.unbalanced.endtag=结束标签&lt;/{0}不对称
jsp.error.unknown_attribute_type=\n\
\ 属性[{0}]的未知属性类型[{1}]。
jsp.error.unsupported.encoding=不支持的编码：[{0}]
jsp.error.variable.either.name=必须在变量指令中指定 name-given 或 name-from-attribute 属性
jsp.error.xml.badStandardAction=无效、标准的action: [{0}]
jsp.exception=在 [{1}] 行处理 [{0}] 时发生异常
jsp.info.ignoreSetting=因为 SecurityManager 被启用，忽略 [{1}] 的 [{0}] 的设置
jsp.message.jsp_added=增加JSP 为路径[{0}]为上下文[{1}]的队列
jsp.message.jsp_queue_update=在上下文[{1}]队列中更新路径为[{0}]的JSP
jsp.message.jsp_removed_excess=从上下文[{1}]的队列中移除额外在路径[{0}]中JSP，
jsp.message.jsp_unload_check=在context[{0}]中检查未加载的jsp，jsp总共:[{1}]队列长度[{2}]
jsp.tldCache.noTldSummary=至少有一个JAR被扫描用于TLD但尚未包含TLD。 为此记录器启用调试日志记录，以获取已扫描但未在其中找到TLD的完整JAR列表。 在扫描期间跳过不需要的JAR可以缩短启动时间和JSP编译时间。
jsp.tldCache.tldInDir=在目录 [{0}]中找到了TLD文件。
jsp.warning.compiler.classfile.delete.fail.unknown=删除生成的class文件失败
jsp.warning.displaySourceFragment=警告：displaySourceFragment初始化参数时参数值无效，将使用默认的值“true”
jsp.warning.dumpSmap=警告：初始化堆内存的值无效。将使用“false”的默认值
jsp.warning.enablePooling=警告：initParam enablePooling的值无效。将使用默认值“true”
jsp.warning.fork=警告：initParam的值无效。将使用“true”的默认值

jspc.delete.fail=无法删除文件 [{0}]
jspc.error.fileDoesNotExist=文件参数 [{0}] 不存在
jspc.error.parseThreadCount=不能够转换的线程数[{0}]
jspc.errorCount=错误计数：[{0}]
jspc.usage=用法: jspc <选项> [--] <jsp 目录>\n\
jsp.文件在哪\n\
\    -webapp <dir>         包含Web.应用程序的目录, 哪个jsp页面\n\
\                          将递归处理或任何数量的\n\
\    <file>                要解析为JSP.页面的文件\n\
其他选项包括:\n\
\    -help                 打印.帮助信息\n\
\    -v                    冗余.模式\n\
\    -d <dir>              输出.目录 (默认-Djava.io.tmpdir)\n\
\    -l                    在失败时输出JSP.页面的名称\n\
\    -s                    成功输出JSP.页面的名称\n\
\    -p <name>             目标包.的名称 (默认org.apache.jsp)\n\
\    -c <name>             目标类名.的名称（仅适用于第一个JSP页面）\n\
\    -mapped               为JSP.中的每个HTML行生成单独的write()调用\n\
\    -die[#]               在致命错误.上生成错误返回代码(#) (默认1)\n\
\    -uribase <dir>        uri.目录编译应该是相对的\n\
\                          (默认"/")\n\
\    -uriroot <dir>        与-webapp.相同\n\
\    -compile              编译生成的.servlets\n\
\    -failFast             首次编译错误.终止\n\
\    -webinc <file>        在文件中创建.部分servlet映射\n\
\    -webfrg <file>        在文件中创建.完整的web-fragment.xml\n\
\    -webxml <file>        在文件中创建.完整的web.xml\n\
\    -webxmlencoding <enc> 设置用于读取和写入.Web.xml的编码字符集\n\
\                          文件 (默认是 UTF-8)\n\
\    -addwebxmlmappings    将生成的.Web.xml片段合并到Web.xml文件中网络应用\n\
\                          , 我们正在处理哪个.JSP页面\n\
\    -ieplugin <clsid>     IE浏览器.Java插件的类id\n\
\    -classpath <path>     重写.java.class.path环境变量参数\n\
\    -xpoweredBy           添加.X-Powered-By 响应头\n\
\    -trimSpaces [single]  移除.完全由空格组成的模板文本\n\
\                          (如果"single", 用单个空格替换这样的模板文本)\n\
\    -javaEncoding <enc>   为Java.类设置编码字符集 (默认UTF-8)\n\
\    -source <version>     设置-source.参数到编译器( (默认1.8)\n\
\    -target <version>     设置-target.参数到编译器(默认1.8)\n\
\    -threadCount <count>  编译使用的线程数.\n\
\                          ("2.0C" 意味着每个内核有两个线程)\n
jspc.webfrg.footer=\n\
</web-fragment>\n\
\n
jspc.webfrg.header=<?xml version="1.0" encoding="{0}"?>\n\
<web-fragment xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n\
\              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\
\              xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n\
\                      http://xmlns.jcp.org/xml/ns/javaee/web-fragment_4_0.xsd"\n\
\              version="4.0"\n\
\              metadata-complete="true">\n\
\  <name>org_apache_jasper.jspc</name>\n\
\  <distributable/>\n\
<!--\n\
由 Apache Tomcat JspC 自动生成。\n\
-->\n\
\n
jspc.webinc.footer=\n\
<!--\n\
由Apache Tomcat JSPC自动创建的内容结束。\n\
-->\n\
\n
jspc.webinc.header=\n\
<!--\n\
由 Apache Tomcat JspC 自动生成。\n\
-->\n\
\n
jspc.webinc.insertEnd=<!-- JSPC servlet 映射结束 -->
jspc.webinc.insertStart=<!-- JSPC servlet 映射开始 -->
jspc.webxml.footer=\n\
</web-app>\n\
\n
jspc.webxml.header=<?xml version="1.0" encoding="{0}"?>\n\
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n\
\         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\
\         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee\n\
\                 http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n\
\         version="4.0"\n\
\         metadata-complete="false">\n\
<!--\n\
由 Apache Tomcat JspC 自动生成。\n\
-->\n\
\n

jstl.OSAfterWriter=如果已使用写入程序，则无法使用输出流
jstl.urlMustStartWithSlash=在指定了“context”属性的URL标记中，“url”和“context”都必须以斜杠字符开头
jstl.writerAfterOS=如果已使用输出流，则无法使用编写器

org.apache.jasper.compiler.TldCache.servletContextNull=提供的 ServletContext 为 null
org.apache.jasper.servlet.TldScanner.webxmlAdd=从资源路径[{0} ]加载URI[{1}]的TLD
org.apache.jasper.servlet.TldScanner.webxmlFailPathDoesNotExist=无法使用路径 [{0}] 和 URI [{1}] 处理TLD。指定的路径不存在。

xmlParser.skipBomFail=解析XML输入流时，跳过BOM失败。

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# net resources
endpoint.err.close=Caught exception trying to close socket
endpoint.err.handshake=Handshake failed
endpoint.err.unexpected=Unexpected error processing socket
endpoint.warn.noExector=Failed to process socket [{0}] in state [{1}] because the executor had already been shutdown
endpoint.warn.noDisableCompression='Disable compression' option is not supported by the SSL library {0}
endpoint.warn.noHonorCipherOrder='Honor cipher order' option is not supported by the SSL library {0}
endpoint.warn.noInsecureReneg=Secure re-negotiation is not supported by the SSL library {0}
endpoint.warn.unlockAcceptorFailed=Acceptor thread [{0}] failed to unlock. Forcing hard socket shutdown.
endpoint.warn.executorShutdown=The executor associated with thread pool [{0}] has not fully shutdown. Some application threads may still be running.
endpoint.debug.channelCloseFail=Failed to close channel
endpoint.debug.destroySocket=Destroying socket [{0}]
endpoint.debug.pollerAdd=Add to addList socket [{0}], timeout [{1}], flags [{2}]
endpoint.debug.pollerAddDo=Add to poller socket [{0}]
endpoint.debug.pollerProcess=Processing socket [{0}] for event(s) [{1}]
endpoint.debug.pollerRemove=Attempting to remove [{0}] from poller
endpoint.debug.pollerRemoved=Removed [{0}] from poller
endpoint.debug.socket=socket [{0}]
endpoint.debug.socketCloseFail=Failed to close socket
endpoint.debug.socketTimeout=Timing out [{0}]
endpoint.debug.unlock=Caught exception trying to unlock accept on port {0}
endpoint.executor.fail=Executor rejected socket [{0}] for processing
endpoint.init.bind=Socket bind failed: [{0}] {1}
endpoint.init.listen=Socket listen failed: [{0}] {1}
endpoint.init.notavail=APR not available
endpoint.accept.fail=Socket accept failed
endpoint.getAttribute=[{0}] is [{1}]
endpoint.poll.limitedpollsize=Failed to create poller with specified size of {0}
endpoint.poll.initfail=Poller creation failed
endpoint.poll.fail=Critical poller failure (restarting poller): [{0}] {1}
endpoint.poll.error=Unexpected poller error
endpoint.process.fail=Error allocating socket processor
endpoint.processing.fail=Error running socket processor
endpoint.sendfile.error=Unexpected sendfile error
endpoint.sendfile.addfail=Sendfile failure: [{0}] {1}
endpoint.setAttribute=Set [{0}] to [{1}]
endpoint.timeout.err=Error processing socket timeout
endpoint.apr.failSslContextMake=Unable to create SSLContext. Check that SSLEngine is enabled in the AprLifecycleListener, the AprLifecycleListener has initialised correctly and that a valid SSLProtocol has been specified
endpoint.apr.invalidSslProtocol=An invalid value [{0}] was provided for the SSLProtocol attribute
endpoint.apr.noSendfileWithSSL=Sendfile is not supported for the APR/native connector when SSL is enabled
endpoint.apr.noSslCertFile=Connector attribute SSLCertificateFile must be defined when using SSL with APR
endpoint.apr.pollAddInvalid=Invalid attempted to add a socket [{0}] to the poller
endpoint.apr.pollError=Poller failed with error [{0}] : [{1}]
endpoint.apr.pollUnknownEvent=A socket was returned from the poller with an unrecognized event [{0}]
endpoint.apr.remoteport=APR socket [{0}] opened with remote port [{1}]
endpoint.nio.selectorCloseFail=Failed to close selector when closing the poller
endpoint.nio2.exclusiveExecutor=The NIO2 connector requires an exclusive executor to operate properly on shutdown

channel.nio.interrupted=The current thread was interrupted
channel.nio.ssl.notHandshaking=NOT_HANDSHAKING during handshake
channel.nio.ssl.handhakeError=Handshake error
channel.nio.ssl.unexpectedStatusDuringWrap=Unexpected status [{0}] during handshake WRAP.
channel.nio.ssl.unexpectedStatusDuringUnwrap=Unexpected status [{0}] during handshake UNWRAP.
channel.nio.ssl.invalidStatus=Unexpected status [{0}].
channel.nio.ssl.netInputNotEmpty=Network input buffer still contains data. Handshake will fail.
channel.nio.ssl.netOutputNotEmpty=Network output buffer still contains data. Handshake will fail.
channel.nio.ssl.appInputNotEmpty=Application input buffer still contains data. Data would have been lost.
channel.nio.ssl.appOutputNotEmpty=Application output buffer still contains data. Data would have been lost.
channel.nio.ssl.eofDuringHandshake=EOF during handshake.
channel.nio.ssl.timeoutDuringHandshake=Timeout during handshake.
channel.nio.ssl.remainingDataDuringClose=Remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead
channel.nio.ssl.pendingWriteDuringClose=Pending write, so remaining data in the network buffer, can't send SSL close message, force a close with close(true) instead
channel.nio.ssl.invalidCloseState=Invalid close state, will not send network data.
channel.nio.ssl.unwrapFail=Unable to unwrap data, invalid status [{0}]
channel.nio.ssl.wrapFail=Unable to wrap data, invalid status [{0}]
channel.nio.ssl.incompleteHandshake=Handshake incomplete, you must complete handshake before reading data.
channel.nio.ssl.closing=Channel is in closing state.
channel.nio.ssl.invalidBuffer=You can only read using the application read buffer provided by the handler.

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

acceptor.stop.fail=Le thread [{0}] de l''accepteur ne s''est pas arrêté proprement
acceptor.stop.interrupted=Une interruption s''est produite lors de l''attente de l''arrêt du thread [{0}] de l''accepteur

channel.nio.interrupted=Le thread en cours a été interrompu
channel.nio.ssl.appInputNotEmpty=Le tampon d'entrée de l'application contient toujours des données, des données ont été perdues
channel.nio.ssl.appOutputNotEmpty=Le tampon de sortie de l'application contient toujours des données, des données ont été perdues
channel.nio.ssl.closeSilentError=Il y a eu une exception en essayant de fermer proprement la connection, comme prévu
channel.nio.ssl.closing=Le canal est en état de fermeture
channel.nio.ssl.eofDuringHandshake=EOF pendant la négociation
channel.nio.ssl.expandNetInBuffer=Augmentation de la taille du tampon d''entrée réseau à [{0}] octets
channel.nio.ssl.expandNetOutBuffer=Augmentation de la taille du tampon de sortie réseau à [{0}] octets
channel.nio.ssl.foundHttp=Une requête HTTP non cryptée a été trouvée sur la connection qui aurait dû être cryptée par TLS
channel.nio.ssl.handshakeError=Erreur lors de la négociation
channel.nio.ssl.incompleteHandshake=La négociation est incomplète, elle doit être terminée pour pouvoir lire des données
channel.nio.ssl.invalidCloseState=Etat de fermeture invalide, aucune donnée ne sera envoyée sur le réseau
channel.nio.ssl.invalidStatus=Etat inattendu [{0}]
channel.nio.ssl.netInputNotEmpty=Le tampon d'entrée du réseau contient toujours des données, la négociation va échouer
channel.nio.ssl.netOutputNotEmpty=Le tampon de sortie du réseau contient toujours des données, la négociation va échouer
channel.nio.ssl.notHandshaking=NOT_HANDSHAKING pendant la négociation SSL
channel.nio.ssl.pendingWriteDuringClose=Une écriture est en cours donc des données sont toujours présentes dans le tampon réseau, impossible d'envoyer le message de fermeture de SSL mais le socket sera fermé de toutes manières
channel.nio.ssl.remainingDataDuringClose=Des données sont toujours présentes dans le tampon réseau, impossible d'envoyer le message de fermeture de SSL mais le socket sera fermé de toutes manières
channel.nio.ssl.sniDefault=Incapacité d'accumuler assez d'information pour déterminer le nom du hôte SNI demandé.  Valeur par défaut utilisée.
channel.nio.ssl.sniHostName=Le nom d''hôte SNI extrait pour la connexion [{0}] est [{1}]
channel.nio.ssl.timeoutDuringHandshake=Timeout pendant la négociation
channel.nio.ssl.unexpectedStatusDuringUnwrap=Statut inattendu [{0}] lors de l''UNWRAP de la négociation
channel.nio.ssl.unexpectedStatusDuringWrap=Statut inattendu [{0}] lors du WRAP de la négociation
channel.nio.ssl.unwrapFail=Incapable de désenrober les données ("unwrap data"), statut invalide [{0}]
channel.nio.ssl.unwrapFailResize=Impossible de faire l''unwrap des données parce que le tampon est trop petit, statut invalide [{0}]
channel.nio.ssl.wrapFail=Impossible d''enrober (wrap) les données, le status est invalide [{0}]

endpoint.accept.fail=Aucun socket n'a pu être accepté
endpoint.alpn.fail=Erreur de configuration de la terminaison pour ALPN en utilisant [{0}]
endpoint.alpn.negotiated=Le protocole [{0}] a été négocié en utilisant ALPN
endpoint.apr.failSslContextMake=Incapable de créer un SSLContext. Vérifier que SSLEngine est activé dans l'AprLifecycleListener, que l'AprLifecycleListener a été correctement initialisé et qu'un protocole SSL valide a été spécifié.
endpoint.apr.invalidSslProtocol=La valeur invalide [{0}] a été fournie pour l''attribut SSLProtocol
endpoint.debug.channelCloseFail=Echec de la fermeture du canal (channel)
endpoint.debug.destroySocket=Destruction du socket [{0}]
endpoint.debug.handlerRelease=Le gestionnaire n'a pas pu retirer le wrapper du socket
endpoint.debug.pollerAdd=Ajout à la addList socket [{0}], inactivité maximale [{1}], drapeaux [{2}]
endpoint.debug.pollerAddDo=Ajout du socket [{0}] au poller
endpoint.debug.pollerProcess=Traitement de(s) évènement(s) [{1}] pour la socket [{0}]
endpoint.debug.pollerRemove=Essai d''enlever [{0}] du poller
endpoint.debug.pollerRemoved=Enlevé [{0}] du poller
endpoint.debug.registerRead=Enregistrement de l’intérêt en lecture pour [{0}]
endpoint.debug.registerWrite=Enregistrement de l’intérêt en écriture pour [{0}]
endpoint.debug.socket=socket [{0}]
endpoint.debug.socketTimeout=Expiration [{0}]
endpoint.debug.unlock.fail=Reçu une exception en essayant de déverrouiller l''accepteur sur le port [{0}]
endpoint.debug.unlock.localFail=Impossible de déterminer l''adresse locales pour [{0}]
endpoint.debug.unlock.localNone=Impossible de débloquer l''accepteur pour [{0}] car l''adresse locale n''était pas disponible
endpoint.duplicateSslHostName=Plusieurs éléments SSLHostConfig ont été fournis pour le nom d''hôte [{0}], les noms d''hôte doivent être uniques
endpoint.err.close=Une exception s'est produite en essayant de fermer le socket
endpoint.err.duplicateAccept=Le socket a été accpeté deux fois. Ceci est un bug connu du kernel Linux. La connection originelle a été traitée normalement et le doublon a été ignoré. Le client ne devrait pas être affecté. Mettre à jour l'OS vers une version qui utilise un kernel 5.10 ou plus récent devrait corriger le problème.
endpoint.err.handshake=Echec de négociation
endpoint.err.unexpected=Erreur inattendue lors du traitement du socket
endpoint.errorCreatingSSLContext=Erreur lors de la création du SSLContext
endpoint.executor.fail=L''exécuteur a rejeté le traitement du socket [{0}]
endpoint.getAttribute=[{0}] est [{1}]
endpoint.init.bind=L''association du socket a échoué : [{0}] [{1}]
endpoint.init.bind.inherited=Pas de canal hérité alors que le connecteur était configuré pour en utiliser un
endpoint.init.listen=L''écoute sur le socket a échoué : [{0}] [{1}]
endpoint.init.unixnotavail=Le support des sockets de domaine Unix n'est pas disponible
endpoint.invalidJmxNameSslHost=Impossible de générer un nom d''objet JMX valide pour le SSLHostConfig associé à l''hôte [{0}]
endpoint.invalidJmxNameSslHostCert=Impossible de générer un nom d''objet JMX valide pour le SSLHostConfigCertificate associé à l''hôte [{0}] et au type de certificat [{1}]
endpoint.jmxRegistrationFailed=Echec de l''enregistrement JMX de l''objet avec le nom [{0}]
endpoint.jsse.noSslContext=Aucun SSLContext n''a été trouvé pour le nom d''hôte [{0}]
endpoint.launch.fail=Impossible de démarrer le nouvel exécutable
endpoint.nio.keyProcessingError=Erreur lors du traitement de la clé de sélection
endpoint.nio.latchMustBeZero=Le compte du latch doit être à zéro ou null
endpoint.nio.nullLatch=Le latch ne peut être null
endpoint.nio.nullSocketChannel=Le canal du socket est invalide car null lors du traitement de l'évênement du poller
endpoint.nio.perms.readFail=Echec d''ajout des permissions en lecture pour le socket de domaine Unix [{0}]
endpoint.nio.perms.writeFail=Echec d''ajout des permissions en écriture pour le socket de domaine Unix [{0}]
endpoint.nio.registerFail=Echec d'enregistrement du socket avec le sélecteur du poller
endpoint.nio.selectorCloseFail=Impossible de fermer le sélecteur lors de la fermeture du poller
endpoint.nio.selectorLoopError=Erreur dans la boucle du sélecteur
endpoint.nio.stopLatchAwaitFail=Les pollers ne se sont pas arrêtés dans le temps imparti
endpoint.nio.stopLatchAwaitInterrupted=Ce thread a été interrompu pendant qu'il attendait l'arrêt des scrutateurs ("pollers")
endpoint.nio.timeoutCme=Exception pendant le traitement du délai d'attente maximum ; le code a été vérifié de manière répétée et aucune modification concurrence n'a pu être trouvée, si vous obtenez cette erreur de manière reproductible merci d'ouvrir un rapport d'erreur sur Tomcat en fournissant les informations pour la reproduire
endpoint.nio2.exclusiveExecutor=Le connecteur NIO2 a besoin d'un accès exclusif à un exécuteur pour pouvoir avoir un comportement prévisible lors de son arrêt
endpoint.nio2.executorService=Le connecteur NIO2 nécessite un service d'exécution, les fils d'exécutions internes de la JVM seront utilisés
endpoint.noSslHostConfig=Pas d''élément SSLHostConfig trouvé avec hostName [{0}] correspondant au defaultSSLHostConfigName du connecteur [{1}]
endpoint.noSslHostName=Aucun nom d'hôte n'a été fourni pour la configuration de l'hôte SSL
endpoint.poll.error=Erreur inattendue du poller
endpoint.poll.fail=Echec critique du poller, redémarrage : [{0}] [{1}]
endpoint.poll.initfail=Echec de création du poller
endpoint.poll.limitedpollsize=Echec de création d''un poller avec la taille spécifiée [{0}]
endpoint.pollerThreadStop=Le thread du poller ne s'est pas arrêté dans le temps imparti
endpoint.portOffset.invalid=La valeur [{0}] pour portOffset est invalide car elle ne peut être négative
endpoint.process.fail=Erreur lors de l'allocation d'un processeur de socket
endpoint.processing.fail=Erreur lors de l’exécution du processeur du socket
endpoint.rejectedExecution=Le traitement du socket a été rejeté pour [{0}]
endpoint.removeDefaultSslHostConfig=Le SSLHostConfig par défaut (de nom [{0}]) ne peut pas être retiré
endpoint.sendfile.addfail=Echec de Sendfile :  [{0}] [{1}]
endpoint.sendfile.closeError=Erreur lors de la fermeture des ressources de sendfile
endpoint.sendfile.error=Erreur lors de sendfile
endpoint.sendfile.tooMuchData=Sendfile a été configuré pour envoyer plus de données que ce qui était disponible
endpoint.sendfileThreadStop=Le thread "sendfile" ne s'est pas arrêté endéans le temps imparti
endpoint.serverSocket.closeFailed=Le socket serveur [{0}] n''a pas pu être fermé
endpoint.setAttribute=Met [{0}] à [{1}]
endpoint.setAttributeError=Impossible de définir l''attribut [{0}] en [{1}]
endpoint.socketOptionsError=Erreur en définissant les options du socket
endpoint.timeout.err=Erreur en traitant le dépassement de temps d'attente du socket
endpoint.tls.cert.encodingError=Les empreintes du certificat ne sont pas disponibles
endpoint.tls.cert.noCerts=Les détails du certificat ne sont pas disponibles car la chaîne de certificats retournée par le SSLContext est vide
endpoint.tls.info=Connecteur [{0}], hôte virtuel TLS [{1}], type de certificat [{2}] configuré depuis {3} et la trust store [{4}]
endpoint.tls.info.cert.keystore=[{0}] avec l''alias [{1}]
endpoint.tls.info.cert.pem=clé [{0}], certificat [{1}] et chaîne de certificats [{2}]
endpoint.unknownSslHostName=Le nom d''hôte SSL [{0}] n''est pas reconnu pour cette terminaison
endpoint.warn.executorShutdown=L''exécuteur associé au pool de threads [{0}] n''est pas complètement arrêté, certains threads d''application peuvent toujours être en cours d''exécution
endpoint.warn.incorrectConnectionCount=Le décompte du nombre de connections est incorrect, la méthode de fermeture d'un même socket a été appelée plusieurs fois
endpoint.warn.noLocalAddr=Impossible de déterminer l''addresse locale pour le socket [{0}]
endpoint.warn.noLocalName=Incapable de déterminer l''hôte local ("local host") pour la socket [{0}]
endpoint.warn.noLocalPort=Impossible de déterminer le port local pour le socket [{0}]
endpoint.warn.noRemoteAddr=Impossible de déterminer l''adresse distante pour le socket [{0}]
endpoint.warn.noRemoteHost=Impossible de déterminer le nom d''hôte distant pour le socket [{0}]
endpoint.warn.noRemotePort=Impossible de déterminer le port distant pour le socket [{0}]
endpoint.warn.noUtilityExecutor=Aucun exécuteur utilitaire configuré, un nouveau sera crée
endpoint.warn.unlockAcceptorFailed=Le thread qui accepte les sockets [{0}] n''a pu être débloqué, arrêt forcé su socket serveur

sniExtractor.clientHelloInvalid=Le message ClientHello n'était pas formaté correctement
sniExtractor.clientHelloTooBig=Le ClientHello n'a pas été présenté dans un seul enregistrement TLS donc l'information SNI n'a pu être extraite
sniExtractor.tooEarly=Il est illégal d'appeler cette méthode avant que le hello du client ait été traité

socket.closed=Le socket associé à cette connection a été fermé
socket.sslreneg=Exception lors de la renégociation de la connection SSL

socketProperties.negativeUnlockTimeout=La valeur négative pour unlockTimeout a été ignorée

socketWrapper.readTimeout=Timeout en lecture
socketWrapper.writeTimeout=Timeout en écriture

sslHostConfig.certificate.notype=Plusieurs certificats ont été spécifiés et au moins un n'a pas d'attribut type
sslHostConfig.certificateVerificationInvalid=La valeur de vérification de certificat [{0}] n''est pas reconnue
sslHostConfig.certificateVerificationWithHttp2=L''hôte virtuel TLS [{0}] est configuré avec la validation optionelle du certificat, et le connecteur qui l''utilise est configuré pour supporter l''upgrade vers h2. HTTP/2 sur TLS ne permet pas la validation optionelle du certificat.
sslHostConfig.fileNotFound=Le fichier [{0}] configuré n''existe pas.
sslHostConfig.invalid_truststore_password=Le mot de passe de la base de confiance n'a pas pu être utilisé pour déverrouiller et ou valider celle ci, nouvel essai en utilisant un mot de passe null pour passer la validation
sslHostConfig.mismatch=La propriété [{0}] a été fixée sur le SSLHostConfig nommé [{1}] et est pour la syntaxe de configuration [{2}] mais le SSLHostConfig est utilisé avec la syntaxe de configuration [{3}]
sslHostConfig.opensslconf.alreadyset=La tentative de définition d'un autre OpenSSLConf est ignorée
sslHostConfig.opensslconf.null=L'OpenSSLConf nul a été ignoré
sslHostConfig.prefix_missing=Le protocole [{0}] a été ajouté à la liste des protocoles du SSLHostConfig nommé [{1}], vérifier qu''un préfixe +/- ne manque pas

sslHostConfigCertificate.mismatch=La propriété [{0}] a été définie sur le SSLHostConfigCertificate nommé [{1}] et est pour un certificat de stockage de type [{2}] mais le certificat est utilisé avec un stockage de type [{3}]

sslImplementation.cnfe=Impossible de créer une SSLImplementation avec la class [{0}]

sslUtilBase.active=Les [{0}] qui sont actifs sont : [{1}]
sslUtilBase.aliasIgnored=Le mode FIPS est activé donc le nom d''alias [{0}] sera ignoré, s''il il y a plus d''une clé dans la keystore, la clé utilisée dépendra de son implémentation
sslUtilBase.alias_no_key_entry=Le nom alias [{0}] n''identifie pas une entrée de clé
sslUtilBase.invalidTrustManagerClassName=Le trustManagerClassName fourni [{0}] n''implémente pas javax.net.ssl.TrustManager
sslUtilBase.keystore_load_failed=Impossible de changer la base de clés de type [{0}] avec le chemin [{1}] à cause de [{2}]
sslUtilBase.noCertFile=L'attribut certificateFile de SSLHostConfig doit être défini lorsque un connecteur SSL est utilisé
sslUtilBase.noCrlSupport=Le truststoreProvider [{0}] ne supporte pas d''option de configuration certificateRevocationFile
sslUtilBase.noKeys=Aucun alias pour les clés privées n'a été trouvé dans la base de clés
sslUtilBase.noVerificationDepth=Le truststoreProvider [{0}] ne supporte pas l''option de configuration certificateVerificationDepth
sslUtilBase.noneSupported=Aucun des [{0}] spécifiés n''est supporté par le moteur SSL : [{1}]
sslUtilBase.skipped=Tomcat interprête l''attribut [{0}] de manière à être cohérent ave la dernière branche de développement d''OpenSSL. Certains de ceux qui ont été spéifiés [{0}] ne sont pas suportés par le moteur SSL configré pour ce connecteur (qui pourrait utiliser JSSE ou une version antérieure d''OpenSSL) et ont été ignorés: [{1}]
sslUtilBase.ssl3=SSLv3 a été explicitement activé.  Ce protocole est connu comme non-sécurisé.
sslUtilBase.tls13.auth=L’implémentation JSSE de TLS 1.3 ne supporte pas l'authentification après la négociation initiale, elle est donc incompatible avec l’authentification optionnelle du client
sslUtilBase.trustedCertNotChecked=Les dates de validité du certificat de confiance dont l''alias est [{0}] n''ont pas été vérifiées car sont type est inconnu
sslUtilBase.trustedCertNotValid=Le certificat de confiance avec l''alias [{0}] et le DN [{1}] n''est pas valide à cause de [{2}], les certificats signés par ce certificat de confiance SERONT acceptés

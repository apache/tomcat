# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

asyncChannelGroup.createFail=无法为WebSocket客户端创建专用的异步通道组，这是防止复杂类加载程序环境（如JavaEE容器）中内存泄漏所必需的

asyncChannelWrapperSecure.closeFail=干净的关闭通道失败
asyncChannelWrapperSecure.eof=意外的流结尾
asyncChannelWrapperSecure.statusUnwrap=unwrap()操作后SSLEngineResult 的意外状态

backgroundProcessManager.processFailed=后台进程失败

caseInsensitiveKeyMap.nullKey=不允许 Key 是 Null

perMessageDeflate.alreadyClosed=转换器已经关闭且可能永远不会使用
perMessageDeflate.deflateFailed=无法压缩这个WebSocket压缩结构
perMessageDeflate.duplicateParameter=重复定义的扩展参数[{0}]
perMessageDeflate.invalidWindowSize=为[{0}]指定了[{1}]大小的无效窗口。 有效值是从8到15（包括8和15）的整数。

util.invalidType=无法强制值[{0}]转为[{1}]类型（不支持次类型）。
util.notToken=一个非法的扩展参数被指定为名称[{0}]和值[{0}]
util.unknownDecoderType=无法识别该解码器类型[{0}]

wsFrame.byteToLongFail=提供了太多字节([{0}])，转换成一个长的字节。
wsFrame.closed=在一个关闭的控制帧后受到了一个新的帧.
wsFrame.controlFragmented=接收到分段的控制帧，但控制帧可能不被分割。
wsFrame.controlNoFin=发送一个没有设置的控制帧。控制帧不允许使用连续帧。
wsFrame.controlPayloadTooBig=以大于125字节的最大允许值的大小[{0}]的有效载荷发送控制帧。
wsFrame.invalidUtf8Close=接收到一个WebSocket关闭帧，其关闭原因包含无效的UTF-8字节序列
wsFrame.notMasked=客户端帧未被屏蔽，但必须屏蔽所有客户端帧
wsFrame.partialHeaderComplete=接收到WebSocket帧. fin [{0}], rsv [{1}], OpCode [{2}], payload 长度 [{3}]
wsFrame.sessionClosed=无法处理客户端数据，因为会话已被关闭
wsFrame.textMessageTooBig=解码的文本消息对于输出缓冲区太大，终结点不支持部分消息
wsFrame.wrongRsv=对于具有opCode [{1}]的消息，客户端帧将保留位设置为[{0}]，此端点不支持

wsHandshakeRequest.invalidUri=字符串  [{0}] 不能用来组成一个有效的URI
wsHandshakeRequest.unknownScheme=请求中的计划[{0}]未识别

wsRemoteEndpoint.changeType=发送分段消息时，所有片段必须是相同类型的。
wsRemoteEndpoint.closed=由于 WebSocket session 已关闭，消息将不会被发送
wsRemoteEndpoint.closedDuringMessage=因为 WebSocket session 被关闭，消息的剩余部分将不会被送达
wsRemoteEndpoint.closedOutputStream=由于OutputStream已关闭，不应该调用此方法。
wsRemoteEndpoint.flushOnCloseFailed=会话关闭后仍然启用批处理消息。无法刷新剩余的批量消息
wsRemoteEndpoint.noEncoder=没有为类 [{0}] 的对象指定编码器
wsRemoteEndpoint.nullData=无效空的data 参数
wsRemoteEndpoint.tooMuchData=ping或pong不应该发送超过125字节
wsRemoteEndpoint.wrongState=远程 endpoint 处于 [{0}] 状态，是被调用方法的无效状态

wsSession.closed=WebSocket会话[{0}]已关闭，并且在关闭的会话上不能调用任何方法（除了close（））
wsSession.created=创建WebSocket session [{0}]。
wsSession.doClose=关闭 WebSocket session [{1}]
wsSession.duplicateHandlerPong=已经配置了pong消息处理器
wsSession.duplicateHandlerText=已配置文本消息处理器
wsSession.instanceNew=endpoint 实例注册失败
wsSession.sendCloseFail=给远程端点发送关闭消息失败，session：[{0}]
wsSession.unknownHandler=无法添加消息处理程序[{0}]，因为它是针对无法识别的类型[{1}]

wsWebSocketContainer.asynchronousSocketChannelFail=无法打开与服务器的连接
wsWebSocketContainer.failedAuthentication=无法处理http响应代码[{0}]。服务器不接受身份验证头。
wsWebSocketContainer.invalidExtensionParameters=服务器用客户端无法支持的扩展参数响应
wsWebSocketContainer.missingAnnotation=无法使用POJO类[{0}]，因为它未添加注解@ClientEndpoint
wsWebSocketContainer.missingLocationHeader=处理HTTP响应码 [{0}] 失败。响应头缺少Location
wsWebSocketContainer.missingWWWAuthenticateHeader=无法处理HTTP响应代码[{0}]。 缺少WWW-Authenticate标头作为响应
wsWebSocketContainer.pathNoHost=URI中未指定主机
wsWebSocketContainer.proxyConnectFail=失败连接到已配置的代理 [{0}]。HTTP 响应码是 [{1}]
wsWebSocketContainer.sessionCloseFail=ID 为 [{0}] 的session 没有彻底关闭
wsWebSocketContainer.shutdown=web应用程序正在停止
wsWebSocketContainer.sslEngineFail=无法创建SSLEngine以支持SSL/TLS连接
wsWebSocketContainer.unsupportedAuthScheme=HTTP响应码处理失败[{0}]. Unsupported Authentication 方案 [{1}] 返回到响应

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

applicationContext.addJspFile.iae=JSP 文件 [{0}] 不可用
applicationContext.addListener.iae.cnfe=无法创建类型为 [{0}] 的实例
applicationContext.addListener.iae.wrongType=指定的类型[{0}]不是预期的侦听器类型之一
applicationContext.addRole.ise=上下文被初始化后，角色不能再被添加到[{0}]中
applicationContext.addServlet.ise=无法将servlet添加到上下文[{0}]中，因为该上下文已初始化
applicationContext.attributeEvent=属性事件监听器引发的异常
applicationContext.invalidFilterName=由于筛选器名称[{0}]无效，无法添加筛选器定义。
applicationContext.invalidServletName=由于servlet名称[{0}]无效，无法添加对应servlet的定义。
applicationContext.mapping.error=映射中.的错误
applicationContext.resourcePaths.iae=路径[{0}]不以“/”字符开头
applicationContext.setAttribute.namenull=Name 不能为 null
applicationContext.setSessionTimeout.ise=(:无法为上下文[{0}]设置会话超时，因为该上下文已初始化
applicationContext.setSessionTracking.iae.ssl=为上下文 [{0}] 请求的 session 跟踪模式包括 SSL 和至少一种其他模式。 SSL可能未配置其他模式。
applicationContext.setSessionTracking.ise=当上下文正在运行，无法设置上下文[{0}]的会话跟踪模式

applicationDispatcher.serviceException=Servlet[{0}]的Servlet.service()抛出异常
applicationDispatcher.specViolation.response=原始的ServletResponse或包装后的ServletResponse未传递给RequestDispatcher，原因：违反了SRV.8.2和SRV.14.2.5.1\n\
\n

applicationFilterConfig.preDestroy=):为类型为[{1}]的名为[{0}]的筛选器调用preDestroy 失败
applicationFilterConfig.release=失败的销毁过滤器类型为[{1}]名称为[{0}]

applicationFilterRegistration.nullInitParams=由于name和(或)value为null，无法为过滤器设置初始化参数。name为 [{0}]，value为 [{1}]

applicationPushBuilder.methodNotToken=HTTP方法必须是令牌(token)，但 [{0}] 包含非令牌字符

applicationServletRegistration.setServletSecurity.iae=为部署到名为[{1}]的上下文的Servlet[{0}]指定的空约束

aprListener.aprInitError=基于APR的本地库加载失败.错误报告为[{0}]
aprListener.config=APR/OpenSSL配置：useAprConnector[{0}]，useOpenSSL[{1}]
aprListener.enterAlreadyInFIPSMode=AprLifecycleListener 配置为强制进入FIPS模式，但库已处于FIPS模式[{0}]
aprListener.initializeFIPSSuccess=成功的进入FIPS 模式
aprListener.initializingFIPS=初始化FIPS模式...
aprListener.tcnVersion=安装了基于APR的Apache Tomcat Native库的旧版本[{0}]，而Tomcat建议使用[{1}]的最低版本
aprListener.tooLateForFIPSMode=无法设置FIPSMode：SSL已初始化
aprListener.tooLateForSSLRandomSeed=无法设置 SSLRandomSeed：SSL已经初始化

asyncContextImpl.noAsyncDispatcher=从ServletContext 返回的调度程序不支持异步调度
asyncContextImpl.request.ise=调用方法complete()后或者任意一个dispatch()方法调用后，调用getRequest()方法是非法的
asyncContextImpl.requestEnded=AsyncContext关联的请求已经完成处理。

containerBase.backgroundProcess.cluster=异常处理集群[{0}]后台进程
containerBase.backgroundProcess.unexpectedThreadDeath=后台线程[{0}]意外结束
containerBase.backgroundProcess.valve=处理阀门[{0}]后台进程异常
containerBase.nullName=容器名称不能为null
containerBase.threadedStartFailed=子容器启动失败

defaultInstanceManager.invalidInjection=方法资源注入注解无效
defaultInstanceManager.restrictedContainerServlet=禁止访问类 [{0}]。 它是一个受限制的类（实现了 ContainerServlet 接口）。 必须将 Web 应用程序配置为特权才能加载它
defaultInstanceManager.restrictedFiltersResource=找不到受限制的过滤器属性文件[{0}]
defaultInstanceManager.restrictedListenersResource=无法找到RestrictedListener的配置文件[{0}]

filterChain.filter=Filter 执行抛出一个异常

jreLeakListener.classToInitializeFail=在tomcat启动期间未能加载类[{0}]，以防止可能的内存泄漏。

naming.addEnvEntry=添加环境条目 [{0}]
naming.addResourceEnvRef=添加资源环境引用 [{0}]
naming.invalidEnvEntryType=环境条目[{0}]没有一个有效哦的类型
naming.jmxRegistrationFailed=注册到JMX失败：[{0}]
naming.namingContextCreationFailed=创建上下文名称失败
naming.unbindFailed=解绑对象[{0}]失败
naming.wsdlFailed=未找到 wsdl 文件：[{0}]

standardContext.applicationListener=配置应用程序监听器[{0}]错误
standardContext.applicationSkipped=由于以前的错误，已跳过安装应用程序侦听器
standardContext.backgroundProcess.loader=异常处理加载程序[{0}]后台进程
standardContext.backgroundProcess.resources=异常处理资源[{0}] 后台进程
standardContext.cookieProcessor.null=不允许将上下文的CookieProcessor 设置为null
standardContext.duplicateListener=当前上下文已经配置了监听器[{0}]，重复的定义将被忽略。
standardContext.errorPage.required=ErrorPage不能为null
standardContext.errorPage.warning=警告：在Servlet 2.4中，错误页位置 [{0}] 必须以"/"开头
standardContext.extensionValidationError=尝试校验必需的应用程序扩展时发生错误
standardContext.filterFail=一个或多个筛选器启动失败。完整的详细信息将在相应的容器日志文件中找到
standardContext.filterMap.either=过滤器映射必须指定 <url-pattern> 或 <servlet-name>
standardContext.filterMap.name=Filter mapping 指定了一个未知的 filter名称 [{0}]
standardContext.filterMap.pattern=过滤器映射中的<url-pattern> [{0}] 无效
standardContext.filterStart=启动过滤器异常
standardContext.invalidWrapperClass=[{0}] 不是StandardWrapper的子类
standardContext.isUnavailable=此应用程序目前不可用
standardContext.listenerStart=异常将上下文初始化事件发送到类的侦听器实例.[{0}]
standardContext.listenerStop=例外情况发送上下文删除事件[{0}]，以便列表实例
standardContext.loginConfig.errorPage=表单错误页[{0}]必须以"/"开始
standardContext.loginConfig.errorWarning=警告：Servlet 2.4中，表单错误页[{0}]必须以"/"开始
standardContext.loginConfig.loginPage=表单登录页面 [{0}] 必须以''/''开头
standardContext.loginConfig.loginWarning=警告：在Servlet 2.4 中 Form 登录页[{0}] 必须以 "/" 开头
standardContext.manager=配置类为[{0}]的管理器
standardContext.managerFail=会话管理器无法启动
standardContext.namingResource.init.fail=未能初始化新的命名资源
standardContext.notStarted=名称为[{0}]的上下文还没有启动
standardContext.parameter.duplicate=重复的上下文初始化参数[{0}]
standardContext.predestroy.duplicate=类 [{0}] 的 @PreDestroy 方法定义重复
standardContext.resourcesInit=初始化静态变量错误
standardContext.resourcesStart=启动静态资源出错
standardContext.resourcesStop=停止静态资源时出错
standardContext.securityConstraint.mixHttpMethod=在相同的web资源集合中不允许混用: <http-method> 和 <http-method-omission>
standardContext.securityConstraint.pattern=安全约束中的<url-pattern> [{0}] 无效
standardContext.servletFail=启动时无法加载一个或多个Servlet。 全部的详细信息可在相应的容器日志文件中找到
standardContext.startingContext=启动Context[{0}]出现异常
standardContext.stop.asyncWaitInterrupted=等待卸载延迟毫秒以完成飞行中的异步请求时收到中断。上下文停止将继续，不会有进一步的延迟。
standardContext.stoppingContext=异常停止的上下文使用名为[{0}]
standardContext.threadBindingListenerError=上下文[{0}]配置的线程绑定监听器发生错误
standardContext.urlPattern.patternWarning=警告：在Servlet 2.4中，URL模式[{0}]必须以“/”开头
standardContext.workCreateException=无法从目录[{0}]和catalina_home[{1}]中为上下文[{2}]确定绝对工作目录
standardContext.workCreateFail=无法为上下文[{1}]创建工作目录[{0}]
standardContext.workPath=获取上下文[{0}]的工作路径时发生异常

standardContextValve.acknowledgeException=以100（继续）响应确认请求失败

standardEngine.jvmRouteFail=无法从系统属性设置引擎的jvmRoute 属性
standardEngine.notParent=引擎不能有父容器

standardHost.noContext=没有配置上下文来处理此请求
standardHost.notContext=主机的子节点必须有上下文
standardHost.nullName=主机名是必需的

standardServer.accept.timeout=在调用accept()方法之后，侦听shutdown命令的套接字经历了意外的超时[{0}]毫秒。 这是bug 56684的一个例子？
standardServer.storeConfig.notAvailable=没有将StoreConfig实现注册为名为[{0}]的MBean，因此无法保存配置。合适的MBean通常通过StoreConfigLifecycleListener注册。

standardService.engine.stopFailed=失败停止关联的引擎
standardService.stop.name=正在停止服务[{0}]

standardWrapper.allocate=分配一个servlet实例错误
standardWrapper.destroyInstance=servlet[{0}]实例管理销毁(destroy) 抛出异常
standardWrapper.instantiate=实例化Servlet类[{0}]异常
standardWrapper.isUnavailable=Servlet [{0}]当前不可用。
standardWrapper.notChild=Wrapper容器内部不允许有子容器。
standardWrapper.notFound=Servlet [{0}] 不可用
standardWrapper.serviceException=在路径为[{1}]的上下文中，servlet[{0}]的Servlet.service()引发异常
standardWrapper.unloading=无法分配servlet [{0}]，因为它没有被加载

threadLocalLeakPreventionListener.containerEvent.error=异常处理容器事件[{0}]

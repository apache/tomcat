# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

beanNameELResolver.beanReadOnly=Der Beanname [{0}] ist schreibgeschützt.

elProcessor.defineFunctionInvalidClass=Die Klasse [{0}] ist nicht öffentlich.
elProcessor.defineFunctionInvalidMethod=Die Methode [{0}] in der Klasse [{1}] ist keine öffentliche statische Methode.
elProcessor.defineFunctionInvalidParameterList=Die Parameterliste [{0}] für die Methode [{1}] in der Klasse [{2}] ist nicht gültig.
elProcessor.defineFunctionInvalidParameterTypeName=Der Parametertyp [{0}] für die Methode [{1}] in der Klasse [{2}] ist nicht gültig.
elProcessor.defineFunctionNoMethod=Es wurde keine öffentliche statische Methode [{0}] in der Klasse [{1}] gefunden.
elProcessor.defineFunctionNullParams=Mindestens einer der Eingabeparameter ist null.

expressionFactory.cannotCreate=Die Ausdruckfactory vom Typ [{0}] konnte nicht erstellt werden.
expressionFactory.cannotFind=Die Ausdruckfactory vom Typ [{0}] konnte nicht gefunden werden.
expressionFactory.readFailed=Fehler beim Lesen von [{0}]

importHandler.ambiguousImport=Die Klasse {0}] konnte nicht importiert werden, weil sie mit dem bereits durchgeführten Import von [{1}] in Konflikt steht.
importHandler.ambiguousStaticImport=Der statische Import [{0}] konnte nicht verarbeitet werden, weil er mit dem bereits durchgeführten Import von [{1}] in Konflikt steht.
importHandler.classNotFound=Die Klasse [{0}] konnte nicht importiert werden, weil sie nicht gefunden wurde.
importHandler.invalidClass=Die Klasse [{0}] muss eine öffentliche, in einem exportierten Paket (für Java 9+), nicht abstrakte Klasse und darf keine Schnittstelle sein.
importHandler.invalidClassName=Der Name der zu importierenden Klasse [{0}] muss ein Paket enthalten.
importHandler.invalidClassNameForStatic=Die Klasse [{0}], die für den statischen Import [{1}] angegeben wurde, ist nicht gültig.
importHandler.invalidStaticName=Der Name der zu importierenden statischen Methode bzw. des zu importierenden Felds [{0}] muss eine Klasse enthalten.
importHandler.staticNotFound=Der statische Import [{0}] wurde nicht in der Klasse [{1}] für den Import [{2}] gefunden.

lambdaExpression.tooFewArgs=Es wurden nur [{0}] Argumente für einen Lambdaausdruck angegeben, der mindestens [{1}] Argumente erfordert.

objectNotAssignable=Ein Objekt des Typs [{0}] kann keinem Array von Objekten des Typs [{1}] hinzugefügt werden.
propertyNotFound=Die Eigenschaft [{1}] wurde für den Typ [{0}] nicht gefunden
propertyNotReadable=Die Eigenschaft [{1}] ist für den Typ [{0}] nicht lesbar
propertyNotWritable=Die Eigenschaft [{1}] kann nicht für den Typ [{0}] beschrieben werden
propertyReadError=Fehler beim Lesen von [{1}] für den Typ [{0}]
propertyWriteError=Fehler beim Schreiben von [{1}] für den Typ [{0}]

staticFieldELResolver.methodNotFound=Es wurde keine öffentliche statische Methode mit dem Namen [{0}] in der Klasse [{1}] gefunden.
staticFieldELResolver.notFound=Es wurde kein öffentliches statisches Feld mit dem Namen [{0}] in der (für Java 9+ exportierten) Klasse [{1}] gefunden.
staticFieldELResolver.notWritable=Das Schreiben in statische Felder (in diesem Fall Feld [{0}] in Klasse [{1}]) ist nicht zulässig.

util.method.ambiguous=Es wurde keine eindeutige Methode gefunden: {0}.{1}({2})
util.method.notfound=Methode nicht gefunden: {0}.{1}({2})

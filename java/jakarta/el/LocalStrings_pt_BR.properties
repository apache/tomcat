# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

beanNameELResolver.beanReadOnly=O nome do bean {0}] é somente leitura

elProcessor.defineFunctionInvalidClass=A classe [{0}] não é pública
elProcessor.defineFunctionInvalidMethod=O método [{0}] na classe [{1}] não é um método estático público
elProcessor.defineFunctionInvalidParameterList=A lista de parâmetros [{0}] do método [{1}] na classe [{2}] não é válida
elProcessor.defineFunctionInvalidParameterTypeName=O tipo de parâmetro [{0}] do método [{1}] na classe [{2}] não é válido
elProcessor.defineFunctionNoMethod=Um método estático público [{0}] na classe [{1}] não pôde ser localizado
elProcessor.defineFunctionNullParams=Um ou mais parâmetros de entrada era nulo

expressionFactory.cannotCreate=Não foi possível criar ExpressionFactory do tipo [{0}]
expressionFactory.cannotFind=Não foi possível localizar ExpressionFactory do tipo [{0}]
expressionFactory.readFailed=Falha ao ler [{0}]

importHandler.ambiguousImport=A classe [{0}] não pôde ser importada, pois ela entra em conflito com [{1}] que já foi importado
importHandler.ambiguousStaticImport=A importação estática [{0}] não pôde ser processada, pois ela entra em conflito com [{1}] que já foi importada
importHandler.classNotFound=A classe [{0}] não pôde importada, pois não pôde ser localizada
importHandler.invalidClass=A classe [{0}] deve ser pública, deve estar em um pacote exportado (para Java 9+) e não deve ser abstrata e uma interface
importHandler.invalidClassName=O nome da classe a ser importada [{0}] deve incluir um pacote
importHandler.invalidClassNameForStatic=A classe [{0}] especificada para importação estática [{1}] não é válida
importHandler.invalidStaticName=O nome do método ou campo estático a ser importado [{0}] deve incluir uma classe
importHandler.staticNotFound=A importação estática [{0}] não pôde ser localizada na classe [{1}] para importação [{2}]

lambdaExpression.tooFewArgs=Somente [{0}] argumentos foram fornecidos para uma expressão lambda que requer pelo menos [{1}]

objectNotAssignable=Não é possível incluir um objeto do tipo [{0}] em uma matriz de objetos do tipo [{1}]
propertyNotFound=Não foi possível localizar a propriedade [{1}] no tipo [{0}]
propertyNotReadable=Não foi possível ler a propriedade [{1}] no tipo [{0}]
propertyNotWritable=Não foi possível gravar a propriedade [{1}] no tipo [{0}]
propertyReadError=Erro ao ler [{1}] no tipo [{0}]
propertyWriteError=Erro ao gravar [{1}] no tipo [{0}]

staticFieldELResolver.methodNotFound=Nenhum método estático público correspondente chamado [{0}] localizado na classe [{1}]
staticFieldELResolver.notFound=Nenhum campo público estático denominado [{0}] foi localizado na classe (exportada para Java 9+) [{1}]
staticFieldELResolver.notWritable=Não é permitido gravar nos campos estáticos (nesse caso, o campo [{0}] na classe [{1}])

util.method.ambiguous=Não é possível localizar método inequívoco: {0}.{1}({2})
util.method.notfound=Método não localizado: {0}.{1}({2})
